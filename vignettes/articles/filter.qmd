---
title: "Filter"
vignette: >
    %\VignetteIndexEntry{Filter}
    %\VignetteEngine{quarto::html}
    %\VignetteEncoding{UTF-8}
---

```{r}
#| include: false
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
#| output: false
# library(mpactR)
devtools::load_all()
library(tidyverse)
```

## Load data into R

mpactR requires 2 files as imput: a feature table and metadata file. Both are expected to be comma separated files (*.csv*).

1. peak_table: a peak table in Progenesis format is expected. To export a compatable peak table in Progensis, navigate to the *Review Compounds* tab then File -> Export Compound Measurements. Select the following properties: Compound, m/z, Retention time (min), and Raw abundance and click ok. 
2. metadata: a table with sample information. At minimum the following columns are expected: Injection, Sample_Code, Biological_Group. Injection is the sample name and is expected to match sample column names in the peak_table. Sample_Code is the id for technical replicate groups. Biological Group is the id for biological replicate groups. Other sample metadata can be added, and is encouraged for downstream analysis following filtering with mpactR.

To import these data into R, use the mpactR function `import_data()`, which has the arguments: `peak_table_file_path` and `meta_data_file_path`

```{r}
data <- import_data(example("coculture_peak_table.csv"),
                    example("metadata.csv"))
```

This will create an R6 class object, which will store both the peak table and metadata. Note: you do not need to use `example()` if you are using your own files. This is a package function that allows access to internal package data. If you simply want to play around with the packge using example data, you can follow run the `import_data` function as shown above.

Calling the new mpactr object will print the current peak table in the terminal:

```{r}
data
```

## Accessing data in mpactr object

You can extract the peak table or metadata at any point with `get_raw_data()`, `get_peak_table()` and `get_meta_data()` functions. Both functions will return a `data.table` object with the corresponding information.

### Extract peak table

To extract the raw input peak table with `get_raw_data()`:

```{r}
get_raw_data(data)[1:5, 1:8]
```

The raw peak table will not change as filters are applied to the data. If you want to extract the filtered peak table, use `get_peak_table()`:

```{r}
get_peak_table(data)[1:5, 1:8]
```


### Extract metadata


```{r}
get_meta_data(data)[1:5, ]
```

## Filtering

mpactR provides filters to correct for the following issues observed during preprocessing of tandem MS/MS data: 

- mispicked ions: isotopic patterns that are incorrectly split during preprocessing.
- solvent blank impurities: features overrepresented in a specific group of samples; for example removal of features present is solvent blanks due to carryover between samples.
- non-reproducible ions: those that are inconsistent between technical replicates.
- insource ions: fragment ions created during the first ionization in the tandem MS/MS workflow.

#### Mispicked ions filter

To check for mispicked ions, use mpactR function `filter_mispicked_ions()`. This function takes an `mpactr object` as input, and checks for similar ions with the arguments `ringwin`, `isowin`, `trwin` and `max_iso_shift`. 

Ions in the feature table are flagged as similar based on retention time and mass. Flagged ion groups are suggested to be the result of incorrect splitting of isotopic patterns during peak picking, detector saturation artifacts, or incorrect identification of multiply charged oligomers.

```{r}
data_mispicked <- filter_mispicked_ions(data, ringwin = 0.5, 
                                        isowin = 0.01, trwin = 0.005, 
                                        max_iso_shift = 3, merge_peaks = TRUE,
                                        copy_object = TRUE)
```

Each filter reports progress of filtering, here we can see that 1303 ions were present prior to checking for mispicked ions. 70 ions were found to be similar to another ion and following merging, 1233 ions remain.

```{r}
head(get_similar_ions(data_mispicked))
```

#### Remove ions that are above a threhold in one biological sample group

Removing solvent blank impurities is important for correcting for between-sample carryover and contamination in experimental samples. You can identify and remove these ions with mpactR's `filter_group()` function. `filter_group()` identifies ions above a relative abundance threshold (`group_threshold`) a specific group (`group_to_remove`). To remove solvent blank impurities set `group_to_remove` to the `Biological_Group` in your metadata file which corresponds to your solvent blank samples. 

```{r}
data_blank <- filter_group(data, group_threshold = 0.01,
                            group_to_remove = "Blanks", remove_ions = TRUE,
                            copy_object = TRUE)
```

In this example, 1303 ions were present prior to the group filter. 796 ions were found to be above the relative abundance threshold of 0.01 in "Blanks" samples, leaving 507 ions in the peak table.

#### Remove non-reproducible ions

Ions whose abundance are not consisent between technical replicates (*i.e.*, nonreproducible) may not be reliable for analysis and therefore should be removed from the feature table. Nonreproducible ions are identified by mean or median coefficient of variation (cv) with `filter_cv()`. 

```{r}
data_rep <- filter_cv(data, cv_threshold = 0.2, cv_param = "median", 
                      copy_object = TRUE)
```

In our example dataset, 256 ions were flagged as nonreproducible. These ions were removed, leaving 1047 ions in the feature table.

If you would like to visualize how the CV threshold performed on your dataset, you can extract the CV calculations using mpactR's `get_cv_data()` function and caclulate the percentage of features for plotting. You can look at both mean and median cv as shown in the example below, or you can filter the data by the parameter of choice. 

```{r}
cv <- get_cv_data(data_rep) %>%
  pivot_longer(cols = c("mean_cv", "median_cv"), names_to = "param", values_to = "cv") %>%
  nest(.by = param) %>%
  mutate(data = map(data, arrange, cv),
         data = map(data, mutate, index = 0:(length(cv)-1)),
         data = map(data, mutate, index_scale = index * 100 / length(cv))) 
  
head(cv)
```

The nested data are tibbles with the columns `r colnames(cv$data[[1]])`:

```{r}
#| echo: false

head(cv$data[[1]])
```

There is one tibble for each parameter (either mean or median). We also want to calculate the percentage of features represented by the CV threshold.

```{r}
cv_thresh_percent <- cv %>%
  filter(param == "median_cv") %>%
  unnest(cols = data) %>%
  mutate(diff_cv_thresh = abs(cv - 0.2)) %>%
  slice_min(diff_cv_thresh, n = 1) %>%
  pull(index_scale)
  
cv_thresh_percent
```


Then we can plot percentage of features by CV:

```{r}
#| warning: false
cv %>%
  unnest(cols = data) %>%
  mutate(param = factor(param, levels = c("mean_cv", "median_cv"), labels = c("mean", "median"))) %>%
  ggplot() +
  aes(x = cv, y = index_scale, group = param, color = param) +
  geom_line(size = 2) +
  geom_vline(xintercept = 0.2, color = "darkgrey", linetype = "dashed", size = 1) +
  geom_hline(yintercept = cv_thresh_percent, color = "darkgrey", size = 1) +
  labs(x = "CV", y = "Percentage of Features", param = "Statistic") +
  theme_bw() +
  theme(
    axis.title = element_text(size = 20),
    axis.text = element_text(size = 15),
    legend.position = "inside",
    legend.position.inside = c(.90, .08),
    legend.title = element_blank(),
    legend.text = element_text(size = 15)
  )

```

Here we can see that roughly 80% of features were below the CV threshold meaning 20% were removed at a CV theshold of 0.2.

```{r}
#| include: false
#| eval: false
cv <- cv %>%
  mutate(data = map(data, mutate, dist = cv - lag(cv)),
         data = map(data, mutate, auc = dist * index_scale)) 

# Replicability statistics
mean_n <- get_meta_data(data_rep) %>%
  summarise(count = n_distinct(Injection) / n_distinct(Sample_Code)) %>%
  pull()
  
stdev <- c(1, 0, 0 * (as.integer(mean_n) - 1))
mod_stdev <- sd(stdev) / mean(stdev)

mean_ord_med <- t$data[[2]] %>%
    left_join(select(t$data[[1]], Compound, cv), by = "Compound") %>%
    rename(cv_median = cv.x,
           cv = cv.y) %>%
    arrange(cv_median) %>%
    mutate(param = "mead_ord_med") %>%
    select(param, cv, everything())
  
cv2 <- t %>%
  unnest(cols = data) %>%
  bind_rows(mean_ord_med) %>%
  nest(.by = param)
  
index_cv_mean <- function(x, df, sd) {
  mean(df$index_scale[which(abs(df$cv - x - sd/200) < sd/200)])
}

s <- data.frame(val = 1:(mod_stdev*100)) %>%
  mutate(pos = val/100,
         meanavg = map_dbl(pos, index_cv_mean, df = cv2$data[[1]], sd = mod_stdev),
         meanmed = map_dbl(pos, index_cv_mean, df = cv2$data[[3]], sd = mod_stdev),
         skew = abs(meanmed - meanavg),
         skew_sd = skew * mod_stdev/100
         )

sumskew <- s %>%
  summarise(sum = sum(skew_sd, na.rm = TRUE)) %>%
  pull(sum)        

auc_groups <- t %>%
  unnest(cols = data) %>%
  summarise(auc = sum(auc, na.rm = TRUE), .by = param)
  
filter(auc_groups, param == "median_cv") %>% pull(auc)

sumskew_n <- sumskew / ((filter(auc_groups, param == "median_cv") %>% pull(auc) + filter(auc_groups, param == "mean_cv") %>% pull(auc))/2)
rep <- ((filter(auc_groups, param == "median_cv") %>% pull(auc) + filter(auc_groups, param == "mean_cv") %>% pull(auc))/2) / (mod_stdev*100)
qualscore <- (1 - sumskew_n) * rep * 100

paste0("Reproducibility: ", round(100*rep, 1), "% ", 
       "Skewness: ", round(100*sumskew_n, 1), "% ",
       "Overall: ", round(qualscore, 1), "%")
```

#### Remove insouce fragment ions

Some ions produce fragments during the first ionization of tandem MS/MS, called insouce ions. This can result in ions from one compound being represented more than once in the feature table. If you would like to remove insource ions framgments, you can do so with mpactR's `filter_insource_ions()`. `filter_insource_ions()` conducts ion decovolution via retention time correlation matrices within MS1 scans. Highly correlated ion groups are determined by the `cluster_threshold` parameter and filtered to remvome the low mass features. The highest mass feature is identified as the likely parent ion and retained in the feature table. 

```{r}
data_insource <- filter_insource_ions(data, cluster_threshold = 0.95,
                                      copy_object = TRUE)
```

71 ions were identified and removed during deconvolution of this dataset, leaving 1232 ions in the feature table. 

#### Chaining filters together

Filters can be chained in a customizable workflow, shown below. While filters can be chained in any order, we recommend filtering mispicked ions, then solvent blanks, prior to filtering nonrepoducible or insouce ions. This will allow for incorrectly picked peaks to be merged and any contamination/carryover removed prior to identifying nonreproducible and insource fragment ions.

```{r}
data <- import_data(peak_table = example("coculture_peak_table.csv"),
                    meta_data = example("metadata.csv"))

data_filtered <- filter_mispicked_ions(data) |>
  filter_group(group_to_remove = "Blanks") |>
  filter_cv(cv_param = "median")

```


## Reference semantics

Note: mpactR is built on an R6 class-system, meaning it opperates on reference semantics in which data is updated *in-place*. Compared to a shallow copy, where only data pointers are copied, or a deep copy, where the entire data object is copied in memory, any changes to the original data object, regardless if they are assigned to a new object, result in changes to the original data object. We can see this below.

Where the raw data object has 1303 ions in the feature table:

```{r}
data2 <- import_data(example("coculture_peak_table.csv"),
                    example("metadata.csv"))

get_peak_table(data2)[ , 1:5]
```

Running the `filter_mispicked_ions` filter, with default setting `copy_object = FALSE` (operates on reference semtanics) results in 1233 ions in the feature table:

```{r}
data2_mispicked <- filter_mispicked_ions(data2, ringwin = 0.5, 
                                        isowin = 0.01, trwin = 0.005, 
                                        max_iso_shift = 3, merge_peaks = TRUE,
                                        copy_object = FALSE)

get_peak_table(data2_mispicked)[ , 1:5]
```

Even though we created an object called `data2_mispicked`, the original `data2` object was also updated and now has 1233 ions in the feature table:

```{r}
get_peak_table(data2)[ , 1:5]
```

We recommend using the default `copy_object = FALSE` as this makes for an extremely fast and memory-efficient way to chain mpactR filters together (see **Chaining filters together** section); however, if you would like to run the filters individually with traditional R style objects, you can set `copy_object` to `TRUE` as shown in the filter examples. 

If you are interested in the groups of similar ions flagged in this filter, you can use `get_similar_ions()`. This function returns a `data.table` report the main ion (the ion retained post-merging) and the ions similar to it.

## Summary

mpactR offers mutliple ways to view a summary of data filtering. 

#### View passing and failed ions for a single filter

If you are interested in viewing the passing and failing ions for a single filter, use the `filter_summary()` function.  You must specify which filter you are intested in, either "mispicked", "group", "replicability", or "insouce".

```{r}
mispicked_summary <- filter_summary(data_filtered, filter = "mispicked")
```

Failed ions: 
```{r}
mispicked_summary$failed_ions
```

Passing ions:
```{r}
head(mispicked_summary$passed_ions, 100)
```

If you set `filter` to a filter name that you did not apply to your data, a warning message will be returned.

```{r}
#| error: true
filter_summary(data_filtered, filter = "insource")
```

#### View passing and failed ions for all input ions

You can view the fate of all input ions with the `qc_summary()` function. A data.table reporting the compound id (`compounds`) and if it failed or passed filtering. If the ion failed filtering, its status will report the name of the filter it failed.

```{r}
head(qc_summary(data_filtered)[order(compounds), ])
```

#### Visualize filtering QC with tree map plot

You can visualize filtering efforts with a tree map using the filtering summary obtained from `qc_summary()` and the packages `ggplot2` and `treemapify`.

First we need to determine the number of ions for each ion status in the summary table. You can report the count, however we need to calculate the percent of ions in each group. We have done this in the code chunk below, where we have used `data.table` syntax as the `qc_summary()` returns a `data.table` object. If you are not familar with the package data.table, check out their resources on [gitlab](https://rdatatable.gitlab.io/data.table/).

```{r}
library(ggplot2)
library(treemapify)

ion_counts <- qc_summary(data_filtered)[ , .(count = .N), by = status][
       , percent := (count / sum(count) * 100)]
```

Finally, we plot the treemap:

```{r}
tm <- ggplot(ion_counts) +
  aes(area = percent, fill = status) +
  geom_treemap() +
  geom_treemap_text(aes(label = paste(status, paste0(round(percent, 2), "%"), sep = "\n"),
                        fontface = c("bold"))) 

tm
```

This plot can be customized with ggplot2, for example we no longer need the legend and maybe we want custom colors:

```{r}
tm +
  scale_fill_brewer(palette = "Greens") +
  theme(legend.position = "none")
```

If you want a fast visualization of the treemap, you can pass the mpactr object to the function `plot_qc_tree()`.

```{r}
plot_qc_tree(data_filtered)
```
